import java.time.LocalDateTime

//-------------------------------------------- Базовые конструкции и соглашения ----------------------------------------
var a: Int = 3 + 7 //изменяемая переменная
a=a<<2
val b = a-8 //константа
val c = a&b //типы определяются автоматически, но если значение используется более одного раза,
// задать тип в ручную - хороший тон.
a.toString  //toString есть у всех объектов.
// Когда определяем свои классы, scala предложит имплементацию по-умолчанию.
a   + b//a.+(b) - именно так оно работает.
// Эти записи эквивалентны, однако приоритет операторов определён заранее.
// Это нужно учитывать при определении своих классов, подразумевающих использование методов +-*/
// А ещё, как видно, можно заменять . при вызове метода на пробел(ы?).
"bonjour".sorted //строка - частный случай коллекции, а Char - вполне себе Numeric.
// Поэтому с таким выражением всё ок.

math.sqrt(2)//обращение к функции из пакета.


var s = "Wello hold!"
s.apply(4)//(...) - по умолчанию использование метода apply(...)
//для коллекций принято, что
// val coll = Collection(1,2,3) - создаст коллекцию типа Collection с элементами 1,2 и 3.

14.toOctalString
//Соглашение о использовании скобок при вызове: При вызове метода без параметров можно опускать скобки
//Однако принято писать скобки в случае, когда метод изменяет объект и не писать, если не изменяет.
//Но иногда, без скобок обойтись не получится:
val m = math.pow(2,1024).toString()
//посчитали, преобразовали к строке,вернули 1-ый символ
//3-math.sqrt(3)*math.sqrt(3)

"Scala" * 3 //ох,мнда...

//если параметр один, также можно опустить
10   max 2//применили метод max объекта 10 к объекту 2 сам метод находится в объекте-компаньоне RichInt

//----------------------------------------------------- Main -----------------------------------------------------------
class Main0 { //стандартный, отсылающий к java и c++ вариант точки входа.
  val str = "Hallow world"
  def main(args: Array[String]): Unit = {
    println(str)
  }
}
class Main1 extends App { //Scala-вариант точки входа. Все строчки класса становятся
  val str = "Hallow world"
  println(str)
}

val main1:Main1 = new Main1()
main1.str //немного неочевидно, почему оно так, поэтому не стоит ставить точки входа такого формата где попало.
main1.main(Array.empty)
main1.str

val main0:Main0 = new Main0()
main0.str

//---------------------------------выражения----------------------------------------------------------------------------
//Почти всё в скале - выражение(то есть имеет значение)
val x = -4
val y = if(x>0) 1 else -1 //if возвращает значение
val z = ()                //Unit - это почти как void. только у void - не может быть значений, а у Unit оно одно - ()
val a = if(x>0) 1 else "What is the type???"//if имеет супертип для Int и String - Any, a - тоже Any,
//так как скала - статически типизированный язык.
def varl = if(true) 1  // = if(true) 1 else ()
//; в конце инструкции нужна только если необходимо написать ещё одну инструкцию на той-же строке.
//если инструкцмю нужно написать на 2-х строках, то в месте окончания строки должно стоять что-то,
//что нельзя явно интерпритировать как конец выражения, например, оператор.

def plusOne(x:Int):Int ={
  println(x)
  x+1
}
val b ={
  val c = 2
  val d = 3
  c*d
} //всё, что заключено в {} считается 1 выражением. Его окончательное значение - это значение последней строчки
val c = {
  var x = 0
  x = x+1
} //Оппа, выражения присваивания имеют тип Unit. Так что аккуратнее.
//----------------------------------------------------------------ввод и вывод------------------------------------------
println("abbadabba")
print("avesavva")
printf("Oh, %s, oh %s, %s happens again!","crap","man","C formatting")
//тут всё понятно, но лучше использовать не printf, а интрерполятор формата f"" + print - так контроль типа жестче.
//val str = io.StdIn.readLine() - Читаем строчку из консоли. Тут не сработает, так как это worksheet.
//io.StdIn.readInt (readDouble...) - c контролем типа.
//readLine умеет выводить перед собой строчку: readLine("Let me iiiiiin")
//-----------------------------------------------------for--------------------------------------------------------------
val expr = 1 to 10//Эта фиговина называется Range, содержит в себе просто все элементы от 1 до 10
for(i<-expr) {//for умеет бегать по элемегтам коллекеций(а Range - это коллекция)
  print(i)
}
println()
for(ch<-"Wello") print(ch)//Так тоже можно
//А ещё в скале нет break, хотя есть breakable(но он медленный)
for(i <- 1 to 3; j <- 1 to 3) print(f"${10*i+j}%3d")//есть двумерные циклы, ура!
for(i <- 1 to 3; j <- 1 to 3 if i != j) print(f"${10*i+j}%3d")//Ага нету  break, но есть условия итерации
for(i <- 1 to 3; a = 3-i; j <- a to 3) print(f"${10*i+j}%3d")//Да, это именно то. Мы ввели переменную внутри цикла и испольховали её.

1.to(10).by(2).foreach(println)
(1 to 10 by 2).foreach(println)

for (nameEl<-1 to 10 by 2) println(nameEl+3)

val collection = for(i <- 1 to 10) yield//Эта ересь будет формировать коллекцию из результатов выражения после for.
{// Такая конструкция называется генератором.
  i % 3
}
for(c <- "Wello"; i <- 0 to 1) yield (c+i).toChar
for(i <- 0 to 1; c <- "Wello") yield (c+i).toChar//так сказать, найди 10 отличий.
for { // for expr, потому так тоже будет работать (Я охриневаю с того, какой тут сладкий синтаксис.)
  i <- 9 to 1 // Если использовать {}, то вместо ; в for  можно использовать \n
  from = 9-i
  j <- from to 9
} {
  print(f"${10*i+j}")
}//Хотя, честно говоря, пока что такие конструкции выглядят диковато
//-----------------------------------------------------функции----------------------------------------------------------
def abs(x: Double):Double = if (x >=0) x else -x // Ну, есть функции и они тоже объекты.

val func0:Int=>Int = x=>x+1
val func1:Int=>String = x=> (x+1).toString

val xal = func0.andThen(func1)(7)
val func3 = (x:Int)=>func1(func0(x))

def factor1(n:Int) = //Если функция не рекурсивная, то тип можно явно не указывать.
{
  var r = 1;
  for(i <- 1 to n) r = r*i
  r
}//return лучше не использовать лишнего в скале он скорее для преждевременного завершения функции, чем для вывода значения.
var fo:(Int=>Int) = factor1 _ //вот тут меня заставили использовать _, я так и не понял, зачем. Да и что я тут сделал, тоже не понял, если честно.
factor1(4)
//В рекурсивной функции, вполне очевидно, нужно указывать тип возвращаемого значения.
def factor2(n:Int):Int = if (n == 1) 1 else factor2(n-1)

def decorate(str: String,left:String = "<", right: String = ">") =
  left+str+right //left  и right - аргументы по-умолчанию.
//def decorate(str: String,left = "<", right = ">") а вот так не сработает, но в общем, довольно редкая штука, так что фиг с ним.
decorate("Wello")
decorate(left = "---<",str = "Wello")//использование именнованных переменнх - это круто. особенно, когда много аргументов по-умолчанию
//-----------------------------------------------------функции с произвольным числом аргументов----------------------------
def pirateSpeech(args: String*) = for(i <- args) println(i + " yohoho!")//Функция с переменным числом аргументов.
//(Как же это просто и приятно!)
val coll = Vector(1,2,3,4,5)

def recSum(xs:Double*):Double = xs.sum

recSum()

coll.head //первый элемент
coll.tail //все, кроме первого
pirateSpeech("AAAAAAAA", "Who are you?")                          //использование1
pirateSpeech("AAAAAAAA", "Who are you?","I am an idiot sandwich") //использование2
pirateSpeech((1 to 5).map(x=>x.toString):_*)  //Это, конечно вариант, но если хочется передать последовательность поэлементно, нужно использовать такое:

def recursiveSum(args: Int*): Int =
  if (args.isEmpty) 0
  else args.head + recursiveSum(args.tail: _*)//короче, очевидно, что :_* - это преобразовние последовательности (Seq) к последовательности
  //head - первый элемент, tail - всё, кроме первого элемента(удобно)
recursiveSum(5,10,15)
//---------------------------------------------------процедуры----------------------------------------------------------
//Процедура - это ересь, возвращающая Unit
def printInt(x:Int): Unit = { // не нужно указывать тип + не нужно писать "=". Честно говоря, вообще хз, зачем так. На очен частая вещь.
  print(x)
}
// Idea по-умолчанию подставляет ":Unit =", так что это абсолютно не нужно.
printInt(10)
//---------------------------------------------------lazy---------------------------------------------------------------
val ax = 984567346.toString        //Вычислится сразу, как программа дойдёт до этого места.
def ay = 984567346.toString//Не вычисляется сразу, но будет вычисленно при обращении
lazy val az = 984567346.toString   //Вычислится при первом использовании, но последующие обращения будут дороже, чем к обычной переменной.
//---------------------------------------------------exceptions---------------------------------------------------------
//Исключения имеют тип Nothing что полезно в if else: Если одна ветка имеет тип Nothßåing, то супертип совпадает с типом другой ветки.
def sqrt(x:Double) = if(x>=0) math.sqrt(x) else throw new IllegalArgumentException("x must be >= 0 ")
try{ //блок отлова исключений
  val y = sqrt(-4)
} catch { //сопоставление с образцами
  case ex: IllegalArgumentException => println(f"bad value in $ex")
  case _: Exception => println("Something is wrong exception")//максимально плохая конструкция, такое использовать нельзя.
} finally { // _ - плейсхолдер, используется виесто имени переменной, если она не испльзуется после
  println("instruction done")
}//блок finally выполняется вне зависимости от того, упало исключение, или нет.