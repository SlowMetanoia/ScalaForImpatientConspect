//---------------------------------выражения----------------------------------------------------------------------------
//Почти всё в скале - выражение(то есть имеет значение)
val x = -4
val y = if(x>0) 1 else -1 //if возвращает значение
val z = ()                //Unit - это почти как void. только у void - не может быть значений, а у Unit оно одно - ()
val a = if(x>0) 1 else "What is the type???"//if имеет супертип для Int и String - Any, a - тоже Any,
                                            //так как скала - статически типизированный язык.
if(true) 1  // = if(true) 1 else ()
            //; в конце инструкции нужна только если необходимо написать ещё одну инструкцию на той-же строке.
            //если инструкцмю нужно написать на 2-х строках, то в месте окончания строки должно стоять что-то,
            //что нельзя явно интерпритировать как конец выражения, например, оператор.
val b ={
  val c = 2
  val d = 3
  c*d
} //всё, что заключено в {} считается 1 выражением
val c = {
  var x = 0
  x = x+1
} //Оппа, выражения присваивания имеют тип Unit. Так что аккуратнее.
//----------------------------------------------------------------ввод и вывод------------------------------------------
println("abbadabba")
print("avesavva")
printf("Oh, %s, oh %s, %s happens again!","shit","man","C formatting")
//тут всё понятно, но лучше использовать не printf, а интрерполятор формата f"" + print - так контроль типа жестче.
//val str = io.StdIn.readLine() - Читаем строчку из консоли. Тут не сработает, так как это worksheet.
//io.StdIn.readInt (readDouble...) - c контролем типа.
//readLine умеет выводить перед собой строчку: readLine("Let me iiiiiin")
//-----------------------------------------------------for--------------------------------------------------------------
val expr = 1 to 10//Эта фиговина называется Range, содержит в себе просто все элементы от 1 до 10
for(i<-expr) {//for умеет бегать по элемегтам коллекеций(а Range - это коллекция)
    print(i)
}
println()
for(ch<-"Wello") print(ch)//Так тоже можно
//А ещё в скале нет break, хотя есть breakable(но он медленный)
for(i <- 1 to 3; j <- 1 to 3) print(f"${10*i+j}%3d")//есть двумерные циклы, ура!
for(i <- 1 to 3; j <- 1 to 3 if i != j) print(f"${10*i+j}%3d")//Ага нету  break, но есть условия итерации
for(i <- 1 to 3; a = 3-i; j <- a to 3) print(f"${10*i+j}%3d")//Да, это именно то. Мы ввели переменную внутри цикла и испольховали её.
// Охренеть.
val collection = for(i <- 1 to 10) yield//Эта ересь будет формировать коллекцию из результатов выражения после for.
  {// Такая конструкция называется генератором.
    i % 3
  }
for(c <- "Wello"; i <- 0 to 1) yield (c+i).toChar
for(i <- 0 to 1; c <- "Wello") yield (c+i).toChar//так сказать, найди 10 отличий.
for { // for expr, потому так тоже будет работать (Я охриневаю с того, какой тут сладкий синтаксис.)
  i <- 9 to 1 // Если использовать {}, то вместо ; в for  можно использовать \n
  from = 9-i
  j <- from to 9
} {
  print(f"${10*i+j}")
}//Хотя, честно говоря, покачто такие конструкции выглядят диковато
//-----------------------------------------------------функции----------------------------------------------------------
def abs(x: Double):Double = if (x >=0) x else -x // Ну, есть функции и они тоже объекты.
def factor1(n:Int) = //Если функция не рекурсивная, то тип можно явно не указывать.
{
  var r = 1;
  for(i <- 1 to n) r = r*i
  r
}//return лучше не использовать лишнего в скале он скорее для преждевременного завершения функции, чем для вывода значения.
var fo = factor1 _ //вот тут меня заставили использовать _, я так и не понял, зачем. Да и что я тут сделал, тоже не понял, если честно.
factor1(4)
//В рекурсивной функции, вполне очевидно, нужно указывать тип возвращаемого значения.
def factor2(n:Int):Int = if (n == 1) 1 else factor2(n-1)

def decorate(str: String,left:String = "<", right: String = ">") =
  left+str+right //left  и right - аргументы по-умолчанию.
//def decorate(str: String,left = "<", right = ">") а вот так не сработает, но в общем, довольно редкая штука, так что фиг с ним.
decorate("Wello")
decorate(left = "---<",str = "Wello")//использование именнованных переменнх - это круто. особенно, когда много аргументов по-умолчанию
//-----------------------------------------------------функции с различныи числом аргументов----------------------------
def pirateSpeech(args: String*) = for(i <- args) println(i + " yohoho!")//Функция с переменным числом аргументов.
                                                                              //(Как же это просто и приятно!)

pirateSpeech("AAAAAAAA", "Who are you?")                  //использование1
pirateSpeech("AAAAAAAA", "Who are you?","I don`t know...")//использование2
pirateSpeech((1 to 5).toString)  //Это, конечно вариант, но если хочется передать последовательность поэлементно, нужно использовать такое:

def recursiveSum(args: Int*): Int = {
  if (args.length == 0) 0
  else args.head + recursiveSum(args.tail: _*)//короче, очевидно, что :_* - это преобразовние последовательности (Seq) к последовательности
                                              //элеметов. Но нифига не понятно, почему работает именно так
                                              //head - первый элемент, tail - всё, кроме первого элемента(удобно)
}
recursiveSum(5,10,15)
//---------------------------------------------------процедуры----------------------------------------------------------
//Процедура - это ересь, возвращающая Unit
def printInt(x:Int) { // не нужно указывать тип + не нужно писать "=". Честно говоря, вообще хз, зачем так. На очен частая вещь.
  print(x)
}
                      // Idea по-умолчанию подставляет ":Unit =", так что это абсолютно не нужно.
printInt(10)
//---------------------------------------------------lazy---------------------------------------------------------------
val ax = 984567346.toString        //Вычислится сразу, как программа дойдёт до этого места.
def ay = 984567346.toString//Не вычисляется сразу, но будет вычисленно при обращении
lazy val az = 984567346.toString   //Вычислится при первом использовании, но последующие обращения будут дороже, чем к обычной переменной.
//---------------------------------------------------exceptions---------------------------------------------------------
//Исключения имеют тип Nothing что полезно в if else: Если одна ветка имеет тип Nothing, то супертип совпадает с типом другой ветки.
def sqrt(x:Double) = if(x>=0) math.sqrt(x) else throw new IllegalArgumentException("x must be >= 0 ")
try{ //блок отлова исключений
  val y = sqrt(-4)
} catch { //сопоставление с образцами
  case ex: IllegalArgumentException => println(f"bad value in $ex")
  case _: Exception => println("Something is wrong exception")//максимально плохая конструкция, такое использовать нельзя.
} finally { // _ - плейсхолдер, используется виесто имени переменной, если она не испльзуется после
  println("instruction done")
}//блок finally выполняется вне зависимости от того, упало исключение, или нет.
//---------------------------------------------------упражнения---------------------------------------------------------
//1.
def signum(x: Double) = if(x>0) 1 else if(x<0) -1 else 0
//2.{}:Unit = () Ну, вроде должен быть
//3.
var h,k:Unit = ()
h = k = 1
//4
for( i <- 10 to 0) println(i)
//5
def countdown(n:Int){
  for( i <- n to 0) println(i)
}
//6,8
def strmult(str:String):Int = {
  var r = 1
  for (i <- str)
    r = r * (i.toInt)
  r
}
//7,8
def strmult1(str:String):Int = {
  var r = 1
  str.foreach(c=>{r = r * c.toInt})
  r
}
//9
12
def strmult2(str:String):Int = if(str=="") 1 else str.head*strmult2(str.tail)
//10,11
