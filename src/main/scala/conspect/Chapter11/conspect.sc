import scala.language.postfixOps
import scala.runtime.Nothing$

/**
 * Глава 11: Операторы
 * Не сказать, необходимые, но делают жизнь синтаксически слаще. ++
 */
//--------------------------------------------------Идентификаторы------------------------------------------------------
/**
 * Идентификатор - это имя класса, переменной, метода или любого другого элемента кода.
 * В scala допускается использование символов юни-кода, например, вот такое сработает:
 */
val ╚ = 123
╚

/**
 * На первый взгляд не очень ясно, зачем так, но можно ведь вот так:
 */
def **(x:Double,y:Double) = scala.math.pow(x,y)
**(2,5)
//не очень красиво (красиво сделаем позже), но в целом довольно удобно, если не хочется import math._
/**
 * Есть некоторые ограничения:
 * 1. Нельзя использовать зарезервированные слова
 * val val = 5 - не сработает
 * 2. есть зарезервированные спецсимволы вроде ;'`~", которые просто так использовать в имени тоже не получится
 * Но достаточно окружить имя '<имя>' и можно использовать вообще любые символы. Например, есть в Java такая штука как
 * Thread.yield() В Scala yield - зарезервированное слово, однако если написать Thread.`yield`(), то всё откомпелируется
 * и сработает корректно.
 * Итого: '<имя>' - экранирование, чтобы показать, что всё внутри нужно воспринять как имя.
 */
//-----------------------------------------------Инфексные операторы----------------------------------------------------
/**
 * То есть биннарные операторы. На самом деле, все операторы такого свойства - методы, принимающие единственное значение
 * Вторым операндом для оператора выступает сам объект. Для добавления в свой класс такого чуда достаточно опеределить
 * метод с оператором в качестве имени
 */
class B(val a:Double) extends AnyVal {
  def ** (other:B) = math.pow(a, other.a)
}
val o2 = new B(10)
val o3 = new B(2)
o2 ** o3
//вот теперь красиво
//------------------------------------------------Унарные операторы-----------------------------------------------------
/**
 * Тут всё немного иначе. Чтобы сделать префексный унарный оператор можно использовать 4 символа: +-!~
 * Название метода записывается так:
 * unary_operator
 * Например:
 * unary_-
 * Любой метод без параметров считается постфексным унарным оператором. Например:
 */
class U(str:String){
  def yohoho = str+"yohoho"
}
val o1 = new U("asd")
o1 yohoho

/**
 * Однако чтобы использовать такие конструкции нужно включить scala.language.postfixOps, иначе компилятор будет ругаться
 */
//-------------------------------------------------Операторы присваивания-----------------------------------------------
/**
 * a operator= b работает в точности также как и a = a operator b
 * Однако есть исключения: <= != >= не являются операторами присваивания, также операторы начинающиеся с символа '='
 * такие как == или === не являются операторами присваивания.
 * Если есть метод operator=, то вызван будет сам метод.
  */
//-----------------------------------------------------Приоритет--------------------------------------------------------
/**
 * Когда в одном выражении без скобок есть несколько операторов, первым будет выполнен тот, чей приоритет выше.
 * 1 + 2 * 3 = 7
 * Приоритет в порядке убываниия:
 * 1. Символы операторов, отличающиеся от тех, что ниже.
 * 2. *%/
 * 3. +-
 * 4. :
 * 5. <>
 * 6. ! =
 * 7. &
 * 8. ^
 * 9. |
 * 10. Символы, не являющиеся символами операторов.
 * 11. Операторы присваивания
 * 12. Постфексные операторы имеют приоритет ниже, чем инфексные
 */
//-----------------------------------------------------Ассоциативность--------------------------------------------------
/**
 * Когда в выражении присутиствуют несколько операторов с равным приоритетом, то порядок их выполнения определяется
 * ассоциативностью
 * Например, a/b/c будет выполнено как (a/b)/c), так как / - левоассоциативный оператор.
 * В scala все операторы - левоассоциативные, кроме тех, которые заканчиваются на :
 * Эти - правоассоциативные. Напрмер, a::b::Nil - тоже что a::(b::Nil)
 * При этом, правоассоциативный двухместный оператор - это метод второго аргумента, то есть
 * a::Nil = Nil.::(a)
 */
//-----------------------------------------------------apply и update---------------------------------------------------
/**
 * По-сути это применение функционального синтаксиса к объектам. И это очень удобно.
 * Если есть объект obj и мы пришем obj(arg), мы вызываем соответствующий сингнатуре метод apply объекта obj.
 * Если же obj(arg1) находится слева от знака присваивания, то будет вызван метод update объекта obj(arg1,value),
 * value станет всё, что находится справа от знака присваивания.
 */
class SomeVals[A,B](var interestingVal:A,var notInterestingVal:B){
  def update(values:(A,B)) = {
    interestingVal = values._1
    notInterestingVal = values._2
  }
  override def toString = s"SomeVals($interestingVal, $notInterestingVal)"
}
object SomeVals{
  def apply[A, B](interestingVal: A, notInterestingVal: B): SomeVals[A, B] =
    new SomeVals(interestingVal, notInterestingVal)
}
//apply
val o4 = SomeVals(10,"11")
//update, причём () - тут обязательно, иначе мы попытаемся изменить значение переменной, а не сделать update()
o4() = (12,"31")
//----------------------------------------------Экстаракторы и unapply--------------------------------------------------
/**
 * Экстрактор - это собственно объект с методом unapply.
 * По-сути unapply - противоположность методу apply из объекта - компаньона
 * Чтобы проиллюстрировать нужны некоторые приготовления. Запилим класс двуменых векторов и создадим парочку
 */
class Vector2D(val a:Double,val b:Double){
  override def toString = s"($a,$b)"
  def *(other:Vector2D) = a*other.a + b*other.b
  def +(other:Vector2D) = Vector2D(a+other.a,b+other.b)
}
object Vector2D{
  //unapply должен возвращать Option, чтобы было возможно впихнуть None, если надо.
  def unapply(d: Vector2D):Option[(Double,Double)] = Some((d.a,d.b))
  def apply(a: Double, b: Double): Vector2D = new Vector2D(a, b)
}
val a = Vector2D(1,2)
val b = Vector2D(2,1)
//А теперь сделаем что-то страшное и странное.
val Vector2D(c,d) = a
/**
 * Что это было? Это был вызов unapply.
 * Прчём на самом деле, не совсем простой вызов.
 * Эта строчка была интерпритированна так:
 */
val tupleOpt = Vector2D.unapply(a)
val (c,d) = tupleOpt match{
  case None => throw new MatchError
  //кстати, тут тоже используется unapply. Можно написать без него, но мне лень.
  case Some((t1,t2)) => (t1,t2)
}

/**
 * обычно unapply пишется так, чтобы передавая в конструктор(apply объекта-компаньона) его выходные параметры можно было
 * получить такой же объект. Однако, не обязательно делать именно так. Например, известна проблема в Java:
 * Дата - это строка и её нужно отдельно парсить, придумывать собственный тип и т.д. Так вот
 */
object myDate{
  def unapply(arg: String): Option[Array[Int]] = {
    val result = arg.split('.').map(str=>str.toInt)
    result.length match {
      case 0 => None
      case _:Int => Some(result)
    }
  }
}
val myDate(e) = "12.13.14"
//таким образом myDate - экстрактор для строки
/**
 * Можно создавать экстракторы извлекающие одно значение или не извлекающие значений вовсе.
 * Например:
 */
object myNumber{
  //непроизводительно, но коротко и просто
  def unapply(arg: String): Option[Int] =
    try{
      Some(arg.trim.toInt)
    }catch {
      case ex:NumberFormatException=>None
    }
}
val myNumber(o5) = "789"
//TODO:Тут есть часть про pattern matching, которую я пока плохо понимаю, нужно написать о ней позже.

//---------------------------------------------Динамический вызов-------------------------------------------------------
//TODO:Честно говоря писать про динамику мне сейчас просто в лом. Напишу, если когда-нибудь понадобится. Но она тут есть