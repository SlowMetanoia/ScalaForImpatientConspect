/**
 * case-class и pattern matching
 */
//-------------------------------------------как switch, но лучше-------------------------------------------------------
/**
 * 1. match лучше чем switch
 * 2. match имеет значение
 * 3. match может быть дополнен условием
 * 4. match может включать тип и именовать переменные
 */

val sign = (a:Int)=>a>0 match {
  case true => 1
  case _ if a == 0 => 0
  case false => -1
  case _ => throw new MatchError()
}

val whatIsThis:Any=>String = _ match {
  case i:Int=>"Int"
  case d:Double=>"Double"
  case s:String=>"String"
  case l:List[Any]=>"List"
  case _=>"I don`t know"
}

/**
 * Сопоставления выполняются во время исполнения программы, когда все дженерики уже стёрты, так что нельзя получить
 * сопоставление case m:Map[String,Int], но можно case m:Map[_,_]
 * Однако типы массивов не затираются, так что case a:Array[Int] - вполне себе будет работать.
 * Массивы.
 */
var arr = Array(1,2,3)
arr match {
  //Массив содержит только 0
  case Array(0) =>"0"
  //массив содержит любые 2 элемента
  case Array(x, y) =>s"$x,$y"
  //массив начинается с 0
  case Array(0, _*) =>s"0 ..."
  //любой другой.
  case _ => "smthg else"
}

/**
 * Если 3 case хочется привязать _* к переменной, нужно использовать нотацию @:
 * case Array(0, tail @ _*) => tail.max.toString
 * Выглядит зверски, но вроде работает.
 */
/**
 * С листами работает оператор ::
 * Кортежи поддерживают форму записи кортежей.
 * case (_,1)=>...
 * case (_,0) | (0,_)=>... - для объединения.
 */
/**
 * Вся эта ересь возможна только благодаря экстракторам. Честь им и хвала. В книге подробее, почему.
 * case-class - это классы, оптимизированные для поддержки сравнения с образцом.
 */

/**
 * когда объявляется case-class, автоматически происходит следущее:
 * 1. Каждый парамет конструктора объявляется как val
 * 2. Создаётся объект-компаньон, с методами apply и unapply
 * 3. автоматически генерируются методы toString,equals,copy и HashCode, если это не сделано явно.
 */
case class pair[K,V](k:K,v:V)

/**
 * метод copy кажется бесполезным для неизменяемого объекта, однако его рузкльтат можно изменять при помощи именнованных
 * параметров.
 */
val p = pair(1,"2")
p.copy(k = 3)

/**
 * Инфексная нотация в предложениях case.
 * Когда case class имеет 2 параметра для конструирования, при сопастовлении с образцом он может быть записан в
 * инфексоной форме
 */
val func:Any=>String = _ match {
  case k pair v =>s"$k,$v"
  //тоже что
  case pair(k,v) => s"$k,$v"
  case _=>throw new MatchError()
}

/**
 * (кстати,и ::, и ~, и #:: - тоже case-классы)
 */
/**
 * Сопоставления с образцом можно вкладывать одно в другое.
 */
/**
 * Запечатанные case-классы.
 * При использовании case-классов при сопоставлении с образцом, было бы желательно, чтобы компилятор проверял matching
 * на полноту (чтобы matching мог корректно обработать всех наследников). Для этого нужно объявить суперкласс
 * запечатанным(sealed). В таком случае, все наследники этого класса должны быть объявленны в рамках одного файла.
 * Такое решение спасает от ошибок.
 */
/**
 * Enum в scala нет, но есть его иммитация через case object, честно говоря, выглядит не очень. С другой стороны,
 * Так ли часто нужны эти самые Enum'ы
 */
sealed abstract class Color
case object Red extends Color
case object Green extends Color
case object Blue extends Color
case object Yellow extends Color
var color:Color = Red
color = Blue
color match {
  case Red =>"stop"
  case Green=>"go"
  case Yellow=>"slow down"
  case _=> "wut"
}


//---------------------------------------------------Тот самый Option---------------------------------------------------
//Как оказалось, Option - коллекция и соответственно, работает такая строчка:
var o:Option[Int] =Some(10)
for(some<-o) println(some)//выведет 10 (Int), или не выведет ничего, если там None, так как None - не элемент,
// а объект пустой коллекции
//--------------------------------------------Частично-определённые функции---------------------------------------------
/**
 * Они же кусочные
 * суть в том, что функция может быть не определена на части значений, например:
 */
//При попытке вызвать это чудо с отрицательным аргументом будет кинуто исключение
val sqrt:PartialFunction[Double,Double] = {
  case a:Double if a>0 => math.sqrt(a)
}
//для такой функции автоматически генерируется метод isDefinedAt(n), проверяющий, определена ли функция для n
sqrt.isDefinedAt(-3)
sqrt.isDefinedAt(10)

/**
 * У таких функций есть метод lift преобразующий функцию к определённой на всём множестве и возвращающую Option
 * и есть unlift для обратного преобразования.
 */
