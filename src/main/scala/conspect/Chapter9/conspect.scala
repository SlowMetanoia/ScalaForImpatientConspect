package conspect.Chapter9

import java.io.{File, FileInputStream, PrintWriter}

//вынужден этот конспект писать в объекте, потому что в worksheet что-то слишком многое падает.
object conspect extends App {
  import scala.io.Source
  import scala.io.StdIn.{readDouble, readInt}                    //библиотека для чтения из файлов
  //имя файла и кодировка. кодировку можно опустить, если она совпадает с кодировкой по-умолчанию в системе
  val sourceDir = "\\src\\main\\scala\\conspect\\Chapter9\\"
  val source = Source.fromFile(sourceDir+"input.txt","UTF-8")
  //не находит файл по косвенной ссылке, потому так.
  val lineIterator = source.getLines()      //возвращает итератор (что это такое, нам пока неизвестно, но запомни)
  for(l<-lineIterator) println(l)           //вот так делать можно
  val stringArr = source.getLines.toArray   //и так тоже.
  val AllInOneStr = source.mkString         //а вот это способ почитать всё в одну строку
  //ВАЖНО! Закончив использовать source нужно его source.close
  //если неоходимо обрабатывать файл посимвольно, то можно использовать в качестве итератора сам объект файла
  for(c <- source) print(c)
  //обработка следующего символа без сдвига указателя в файле:
  val buf = source.buffered
  while(buf.hasNext){
    buf.head    //тот самый следующий символ
    buf.next    //он же, но со сдвигом маркера чтения
  }

  //неуниверсвльный, но очень простой способ поделить текст на строчки разделённые пробелами
  /*val tokens = source.mkString.split("//s+")
  println(tokens.mkString(" "))
  //ну и можно всё преобразовать к чиселкам, если хочется.
  val numbers = for(s<-tokens) yield s.toDouble
  //кстати, строчка выше типовая и при этом довольно громоздкая, поэтому. Коротко, функционально, читабельно:
  val numbers2 = tokens.map(_.toDouble)  //делает то-же самое, что и строчка выше.
  */
  /**
   * Вот там чуть выше ерундень, с которой я не разобрался. По-идее, всё должно работать, более того, этот пример
   * я взял из книжки. Однако вот. Кто знает в чём дело - расскажите =)
   * Если нужно обрабатывать смесь цифр и символов, всегда можно воспользоваться java.util.Scanner
   */
  //val age = readInt()//или readDouble, readLong(),etc. - чтение из консоли
  source.close
  /**
   * при чтении из url необходимо знать кодировку. Определить её можно, например по http-заголовку, больше:
   * www.w3.org/international/O-charset
   */
  val source1 = Source.fromURL("https://www.google.com/")
  //вот так ХОБА! и почитали страничку!
  val text = source1.getLines
  println(text.mkString("\n"))
  source1.close()
  val source2 = Source.fromString("Wello hold") //своего рода отладочный вариант
  for(c<-source2) print(c)
  source2.close()
  val source3 = Source.stdin                    //чтение из стандартного потока ввода
  source3.close()
//----------------------------------------------------------------вывод в файл------------------------------------------
  /**
   * Если коротко, то в scala его нет. Но есть в Java и этого хватит.
   */
  val out = new PrintWriter("output.txt")
  for(i<-1 to 100) out.println(i)
  /**
   * всё кроме printf будет работать нормально, если нужен функционал printf - используем интерполятор f""
   */
  out.close()
  //обход катологов и чтение файлов в двоичном режиме тут упоминается. Но я писать об этомм не буду

//---------------------------------------------Сериализация-------------------------------------------------------------
  //я не знаю, что это, напишу позже, если нунжно будет.
  //Как я понял, это способ хранить объекты в файлах подкачки?
  //TODO Serialization
//--------------------------------------Ёлки, палки и cmd---------------------------------------------------------------
  import scala.sys.process._

  /**
   * Не вдаваясь глубоко, скажу, что этот import даёт возможность всячески взаимодействовать
   * с оболочкой командной строки. Например, так:
   */
  println("cmd POWER:")
  "ls -al ..".!
  /**
   * ! - здесь выполняет строчку как команду. если вместо ! поставить !! - вернёт результат строкой
   */
  println(s"cmd POWER:${"ls -al ..".!!}")
  /**
   * Тут вообще очень много крутых вещей, но их очень муторно иллюстрировать, так что я просто перечислю, что есть
   * pipe
   * направление в файл
   * ввод из файла
   * ввод из url
   * и ещё немного приятных мелочей
   */
//----------------------------------------------------regex-------------------------------------------------------------
  //Есть scala.util.matching.Regex, но создать регуляроне выражение можно с с помощью преобразования строки:
  val numPattern = "[0-9]+".r                                 //вот и regex
  //Если нужно в рамках regex использовать /,\,", то есть интерполятор raw
  val wsnumwsPattern = """\s+[0-9]+\s+""".r
  println(wsnumwsPattern.findAllIn("1 and 2").mkString(","))  //findAllIn возвращает итератор по всем вхождениям
  //findFirst возвращает Option[String],где лежит первое вхождение(нет)
  println(wsnumwsPattern.findFirstIn("1 and 2"))
  //чтобы выделить группу в regex, можно использовать ()
  val numnletterPattern = "([0-9]+)([a-z]+)".r
  println(numnletterPattern.findAllIn("1 and 2").mkString(","))
  //TODO: дописать regex, сейчас слишком лень(((
}

