import scala.language.implicitConversions

/**
 * Глава 21: Неявные преобразования.
 * По-сути, это способ спрятать ненужное от пользователя библиотечных штуковин и сделать некоторую работу за него.
 */
class myDouble(val d:Double)extends AnyVal
implicit def myDouble2Double: myDouble=>Double = d=> d.d
val v1 = new myDouble(15.0) + 3.0//преобразование происходит на этапе компиляции
/**
 * Неявные преобразование можно класть в: компаньон исходного типа, целевого типа и текущуюю область видимости. Тогда
 * преобразование точно будет импортированно.
 * Правила неявных преобразований просты, но переписывать их долго. Если коротко, то: простота и однозначность
 */
//-----------------------------------------Неявные параметры------------------------------------------------------------
/**
 * Функция или метод может иметь параметры помеченные словом implicit. Тогда компилятор попытается найти значение
 * нужного типа объявленное как val или def, помеченное ключевым словом implicit в текущей области видимости и
 * объекте-компаньоне типа, связанного с требуемым типом. Если ничего не найдёт - попросит задать явно.
 */
class c1 {
  def f(p:Int)(implicit additional:Int) = p+additional
}

implicit val additionalInt:Int = 15
val o1 = new c1
o1.f(12)

/**
 * Неявные преобразованя также могут использовать неявные параметры
 * Тут будто бы нет неявного преобразования...
 */
def min[T](a:T,b:T)(implicit ord:T=>Ordered[T]):T = if( ord(a)<b ) a else b
min(3,4)
/**
 * Однако наше объявление на деле содержит implicit ord:T=>Ordered[T], то есть так будет работать:
 */
def minimum[T](a:T,b:T)(implicit ord:T=>Ordered[T]):T = if(a<b) a else b
minimum(3,4.0)
//------------------------------------------Снова границы контекста-----------------------------------------------------
/**
 * Итак, параметр типа может иметь границу контекста в виде T:M, где M - Другой обобщённый тип. Это требует в области
 * видимости неявного значения M[T]. Сейчас станет понятно.
 */
//------------------------------------------------Классы типов и функцинальщина-----------------------------------------
/**
 * Класс типа... как это прикольно наверное звучит, для неподготовленного и как же это на самом деле математично.
 * Класс типа во многом похож на трейт, но трейт заставляет реализовывать функционал, а класс типа даёт локально
 * определить этот функционал и использовать его не изменяя исходный класс. Достаточно добавить неявное значение типа
 * локально или импортировать его.
 * Цельно-тянутый пример из книжки:
 */
class Pair[T:Ordering](val p1:T,val p2:T){
  def min:T = {
    import Ordered._
    if(p1>p2) p2 else p1
  }
}

/**
 * Мы не требует подмешивать трейты, исполнять интерфейсы, наследовать классы и т.д. Мы требуем налилчия неявного типа
 * Ordering[T]
 * например, есть класс, вполне очевидно не наследующий и не подмешивающий вообще ничего:
 */
case class Point(x:Double,y:Double)

/**
 * Сделать Pair[Point] мы не можем
 * Но что мы можем, так вот это:
 */
implicit object PointOrdering extends Ordering[Point]{
  override def compare(x: Point, y: Point):Int = x.x+x.y-y.x-y.y match {
    case 0 => 0
    case a:Double => if (a<0) -1 else 1
  }
}

/**
 * С этих пор Pair[Point] будут создаваться с лёгкостью!
 */

val o1 = new Pair[Point](Point(1,2),Point(1,3))

/**
 * Так вот, штуковины типа Ordering и называются классами типов (класс, в смысле категория, не ООП)
 * Создадим же такую ерундовину!
 * Снова цельнотянутый пример
 */
trait NumberLike[T]{
  def plus(x:T,y:T):T
  def divideBy(x:T,y:T):T
  def int2T(n:Int):T
}
object NumberLike{
  implicit object IntNum extends NumberLike[Int] {
    def plus(x: Int, y: Int) = x + y
    def divideBy(x: Int, y: Int) = x / y
    def int2T(a: Int): Int = a
  }
  implicit object DoubleNum extends NumberLike[Double] {
    def plus(x: Double, y: Double) = x + y
    def divideBy(x: Double, y: Double) = x / y
    def int2T(a: Int): Double = a
  }
}

/**
 * среднее значение
 */
def avg[T](coll:Seq[T])(implicit ev:NumberLike[T]): Unit ={
  val d = coll.size
  //хотя вот эта часть у меня написана очень неопрятно...
  ev.divideBy(coll.reduceLeft(ev.plus),ev.int2T(d))
}

/**
 * Впринципе мы можем добавить неявный объект в компаньон и тогда преобразование к нашему неявному классу станет
 * доступно откуда угодно
 */
