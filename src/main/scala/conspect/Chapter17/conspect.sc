import java.lang.Thread.{`yield`, sleep}
import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent._
import scala.concurrent.duration.DurationInt
import scala.util.{Failure, Success}

/**
 * Глава 17: Future
 * УРААААА!
 */
/**
 * Это прикольные асинхронные инструкции, которые можно ждать без кривых циклов типа while(threads.exist(_.isAlive(_)))
 */
val f = Future({sleep(1000);10})
f
val result = Await.result(f,10.seconds)

/**
 * Если в future возникает исключение, оно го значение станет равным future(failure(exception))
 * то есть, если обобщить Future - это объект, который возвращает результат, или исключение в некоторый момент в будущем
 * Не все исключения будут становиться результатом future. Ошибки виртуальной машины и InterruptedException будут
 * распрастроняться как обычно.
 */
val d = Future{throw new Exception("wrong!")}
d
//------------------------------------------------Try[V]----------------------------------------------------------------
/**
 * класс Try[V] как Option[V], но удачное завершение вернёт Success(v), а неудачное Failure(ex), где ex - Throwable
 * Как и Option, его можно обрабатывать через match. Есть метод toOption.
 */
//----------------------------------------------call-back---------------------------------------------------------------
/**
 * Проблема Await ровно в том, что он блокирует основной поток, что грустно.
 * У Future есть метод onComplete(t). он вызывает t и передаёт в неё свой результат по завершении. Такая кострукция и
 * называется обратным вызовом. Но это создаёт проблемы, когда нужно построить длинную композицию вычислений.
 * В таком случае хочется воспринимать Future как сущности, подобные функциям.
 * Такая ситуация:
 */
val fut1 = Future{sleep(100);10}
val fut2 = Future{sleep(10);20}

/**
 * Мы не знаем, когда будут вычислены значения fut1 и fut2, а нам нужно запустить функцию, в которую передаются оба.
 * Тогда при помощи обратных вызовов это будет выглядеть так:
 */
fut1.onComplete {
  case Success(n1)=>
    fut2.onComplete {
      case Success(n2)=> println(s"$n1,$n2")
    }
}
/**
 * Громоздко, учитывая, что тут ещё не хватает обработки исключений
 * Однако, как и в случае с Option, Future[A] - тоже коллекция, единственный возможный элемент которой - это a:A
 * Таким образом
 */
  def func1 ={
    sleep(10);
    10
  }
  def func2 = {
    sleep(100);
    100
  }
val fut3 = Future(func1)
/**
 * Вот так будет выглядеть обратный вызов func2 из func1, обоёрнутого в Future в терминах коллекции
 */
val fut4 = fut1.map(_+func2)
/**
 * элегантно, но пока не полностью параллельно.
 */
val fut5 = Future(func1)
val fut6 = Future(func2)
/**
 * Вот теперь это элегантно, читаемо и параллельно, НО тип возвращаемого значения - Future[Future[Int]]
 * С такими штуками лучше всего боросться при помощи flatmap.
 */
val fut7 =
  fut5.map {n1=>
  fut6.map {n2=>
    n1+n2
  }}

/**
 * Собственно,вот.
 */
val future =
  fut5.flatMap { n1 =>
    fut6.map { n2 =>
      n1 + n2
    }}

/**
 * Казалось бы, уже рчень неплохо, но можно лучше.
 */
val future2 = for(n1<-fut5;n2<-fut6 if n1!=n2 /*+ можно добавить if, если хочется*/ ) yield(n1+n2)
/**
 * Как выше, но короче и с if
 */
/**
 * Есть некоторые штуковины в библиотеке async, если for кажется неясной конструкцией. Например,так:
 */
//val future3 = async {await(fut5) + await(fut6)}//у меня не подключена, но я оставлю тут такую запись.

//-----------------------------------------------отложенный запуск------------------------------------------------------
/**
 * Если значение объявленно, как val, Future начнёт его вычислять тут-же. Однако, если как def, то вычисления начнутся
 * только после обращения к результату. Это может пригодиться, если часть вычислений последовательны, а часть
 * параллельны.
 */
/**
 * Есть специфика для более детальной работы с исключениями, описывать не буду
 * метод zipWith(fut2)(op) принимает другой future и двухместную функцию объединения над элементами. Результат
 * будет обёрнут в Future
 */
val combined = fut5.zipWith(fut6)(_+_)
//---------------------------------------------методы Future------------------------------------------------------------
/**
 * Частенько хочется поделить массив данных на куски и каждый кусок вычислить в отдельном потоке
 * val futures = parts.map(p=>Future{/*обработка части p*/})//результат будет Iterable[Future]
 * после чего нужно подождать все результаты
 * val results = Future.sequence(futures)//Iterable[Future]=>Future[Iterable]
 * можно объединить операции.
 * val results = Future.traverse(parts)(p=>Future{...})
 * Есть также местные аналоги для reduce,fold и scan
 */
//TODO:Контексты, Promise.