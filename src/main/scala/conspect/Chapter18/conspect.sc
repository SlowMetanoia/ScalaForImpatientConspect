import scala.reflect.ClassTag

/**
 * Глава 18: Параметризованные типы
 * Как многие другие главы, эту надо просто читать.
 */
//T1 и Т2 - параметризуемые типы
class Pair[T1,T2](p1:T1,p2:T2)
//ограничение на тип: должен совпадать.
class GPair[T](p1:T,p2:T)
//Установка верхней границы: T должен быть подтипом Comparable[T]
class GCPair[T <: Comparable[T]](p1:T,p2:T){
  //R - дожен быть супертипом T.
  //def replaceFirst[R >: T](other:R) = new GCPair(other,p2)
  //Двойная граница. В данном случае это избыточно.
  def replaceFirst[R >: T <: Comparable[R]](other:R) = new GCPair[R](other,p2)
}
//------------------------------------------Неявные значения и границы контекста----------------------------------------
def a[M,T:M] = {}//
/**
 * Что это такое, я пока не знаю и не могу объяснить, но суть в том, что должно существовать неявное значение типа M[T],
 * методы, использующие это неявное значение должны получать неявный параметр типа M[T].
 */
/**
 * ClassTag. Если нужно использовать массив обобщённого типа T, класс, использующий его будет написан так:
 */
class pair[T:ClassTag](p1:T,p2:T){
  val r = new Array[T](2); r(0) = p1;r(1) = p2
}
//Все эти сложности нужны потому, что на этапе компиляции обобщённые типы исчезают, а объектные и простые типы массивов
//обрабатываются по-разному.
//Границ контекста может быть несколько, но границ сверху и снизу - по одной.
def b[T:ClassTag:Comparable[T] with Cloneable with Serializable]
//--------------------------------------------Ограничения типов---------------------------------------------------------
/**
 * Используется, как кажется, в основном для добавления специфических методов в общий класс или помощи компилятору в
 * трудных ситуациях(когда он не может корректно распознать, откуда взять тип автоматически)
 */
/**
 * Вариативность.
 * Пусть есть класс A и В, наследующий А
 * Есть несоторый контейнер CC[T] и функция опрделённая так:
 * def f(cc:CC[A])
 * можно ли вызвать f(CC[B])? - по-умолчанию - нет, так как CC[B] не наследует CC[A]
 * Если объявить СС[+T], то для всех наследников T будут работать функции, определённые для Т, -Т работает с
 * обратным эффектом. (Наследование - зло.)
 */

//TODO: Вкурить главу ещё раз. Половину не понял.