/**
 * Глава 13: Scala-коллекции
 */
/**
 * Эту главу нужно просто прочитать. Хотя пару интересностей я всё таки напишу.
 * Это интересные методы коллекций:
 * (для Iterable)
 * 1. takeWhile(pred) - возвращает первые элементы, соответствующие пердикату
 * 2. grouped(n) - возвращает итераторы значений от 0 до n, от n до 2*n и т.д.
 * 3. sliding(n) - возвращает итераторы значений от 0 до n, от 1 до n+1 и т.д.
 * (для Seq)
 * 4. sortWith(less) - сортирует при помощи функции less
 * 5. sortBy(f) - сортирует при помощи отображения f в некоторый порядковый тип
 * 6. permutations - итератор всех перестановок коллекции
 * 7. combinations(n) - итератор всех комбинаций длинны n элементов последовательности
 * 8. map(f) - применяет отображение f ко всем элементам коллекции, возвращает новую коллекцию
 * 9. flatmap(f) - применяет отображение f ко всем элементам коллекции, возвращает  результат как плоскую коллекцию.
 * То есть если f переводит элемент в коллекцию, дербанит эту коллекцию и поэлементно добавляет её к результату.
 * Если возвращаемый тип - Option, то в результат попадут только Some()
 * 10. transform(f) - как map, но изменяет исходную коллекцию(только для изменяемых коллекций)
 * 11. foreach(p) - как map, но не взвращает значениий
 * 12. reduce, fold, scan применяют двуместную функцию над коллекцией.
 * reduceLeft(op): рекурсивно применяет op на левый и второй слева элемент, кладёт результат во второй слева и
 * убирает левый до тех пор, пока коллекция не скукожится до 1 элемента, который и станет результатом.
 * reduceRight(op) - брат - близнец
 * fold(init)(op) - даёт возможность задать начальное значение,
 * которое будет обрабатываться с первым элементом справа(слева)
 * кстати, для fold не обязательно, чтобы init был того-же типа, что элементы коллекции (например, преобразование к
 * строке можно написать так:)
 */
def mkStr[A](a:Seq[A],left:String,right: String,sep:String): String =
  a.foldLeft(left)(_+_+sep) + right
mkStr(Seq(1,2,3),"<",">",".")

/**
 * scan(init)(op) - создаёт коллекцию промежуточных значений свёртки из fold
 * 13. zip(coll) - создаёт коллекцию кортежей из элементов первой и второй коллекции.
 * 14. zipWithIndex - коллекцию пар (значение,индекс)
 */
//-------------------------------------------------Stream(LazyList)-----------------------------------------------------
/**
 * Можно думать об итераторах, как о списках с ленивым хвостом.
 * Что если хочется потокобезопасности?
 * Stream - это неизменяемый список с ленивым хвостом
 * То есть допустим есть вот такая вот запись
 * (#:: - как :: в обычных листах)
 * Кстати, в книжке речь про Streams, но они объявленны как deprecated, так что вот.
 */
def NumsFrom(n:BigInt):LazyList[BigInt] = n #:: NumsFrom(n+1)
//бесконечная, но ленивая штука
val a = NumsFrom(10)
a.tail
//всё также в точности.
val b #:: t = a
//естественно такая операция тоже будет ленивой.
val c = a.map(a=>a*a)
/**
 * Для того, чтобы взять несколько элементов, есть take, а чтобы заставить инициализировать ленивые значения, есть force
 */
val d = c.take(5).force

/**
 * view делает тоже самое для других коллекций, правда с некоторой версии scala view.force стало deprecated
 * в отличае от стримов, view не кэширует результатов, так что, например, поиск лучше делать через view
 * Цельнотянутый пример из книжки: поск зеркальных полиндромов
 */
val squirePalindromes = (1 to 100000000).view
  .map {x=>x*x}
  .filter {x=>x.toString == x.toString.reverse}
squirePalindromes.take(10).mkString(",")
//Любой метод, задействующий значения здесь сработает как force.

/**
 * Есть преобразования из скала-коллекций в java-коллекции и обратно.
 */
/**
 * Говорят, можно организовывать параллельную работу в коллекциях при помощу par, но тут это не работает, так что я хз.
 */