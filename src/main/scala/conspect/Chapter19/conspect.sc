import org.graalvm.compiler.debug.DebugContext.Description

import scala.collection.immutable.HashMap

/**
 * Глава 19: Дополнительные типы.
 * И тут без чтения не обойтись. Кода будет мало.
 */
//----------------------------------------------Типы-одиночки-----------------------------------------------------------
//Есть класс.
class Z0{
  var name:String= ""
  var description:String = ""
  def setName(name: String):Z0 = {this.name = name; this}
  def setDescription(description: String):Z0 = {this.description = description; this}

  override def toString = s"Z0($name, $description)"
}
//теперь запилим экземпляр и сделаем цепочку вызовов.
val z0 = new Z0
z0.setDescription("a").setName("b")
//унаследуем, повторим
class Z1 extends Z0{
  var sur = ""
  def setSur(sur:String) = {this.sur = sur;this}
}
val z1 = new Z1
z1.setName("c").setDescription("d")

/**
 * Оппа, получилася Z0 и вызвать setSur уже не выйдет
 * чтобы этого не происходило, нужно заменить тип возвращаемого значения на this.type
 * Кроме того, если есть object, object.type будет его типом и можно создать функцию с аргументом такого типа,
 * если хочется.
 */
//TODO: ----------------------------------------------------Проекции типов----------------------------------------------------
//Псевдонимы типво через type:
type IntMap[T] = scala.collection.immutable.HashMap[Int,T]
//Структурный тип - это описания сигнатур полей, которые должнен иметь тип, чтобы этому типу соответствовать.
def sayHello(someone:{def hello:String}) = println(someone.hello)

//инфиксным является любой тип с 2 параметрами типа. Его можно записывать в инфексной форме:
val a0:Int HashMap String = new HashMap[Int,String]()
//Лёгким движением руки получаем красивую математичную запись:
type -->[A,B] = HashMap[A,B]
val a1: Int --> String = new HashMap[Int,String]()
//TODO: -------------------------------------------------Экзистенциальный тип-------------------------------------------------
//TODO: -------------------------------------------------Scala DI-------------------------------------------------------------
/**
 * В абстрактных классах и трейтах можно объявить абстрактный тип, конкретика будет определяться в наследниках.
 */
abstract class c0{
  type T
  def f0:T
}
//TODO: -----------------------------------------------Родовой поолиморфизм---------------------------------------------------
//TODO: -----------------------------------------------Типы высшего порядка---------------------------------------------------
