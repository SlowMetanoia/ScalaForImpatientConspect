/**
 * Глава 10: Трейты
 */

import java.io.{IOException, PrintWriter}
//-----------------------------------------------------трейты-----------------------------------------------------------
/**
 * Трейт - это интерфейс из java, методы и поля которого могут иметь реализацию по-умолчанию
 */
//в точности интрефейс
trait A{
  //не нужно объявление абстрактным. Нет реализации = абстрактный
  def printMe
}
//С реализцией
trait B{
  def printMe = println(s"${this.getClass} $this")
}
//Нет сппециального слова для исполнения трейта. Потому трейты "наследуются"
//Собственно, у трейтов, пожалуй больше общего с классами, чем с интерфейсами, тем не менее, они предоставляют полный функционал интерфейсов.
class C extends B {
  val char = 'C'
  override def toString = s"C(char)"
}
trait D {
  def sayHello = println("Hello")
}
//исполнение нескольких трейтов через with
class E extends B with D

/**
 * Трейты можно подмешивать на этапе создания объекта, но эту возможность стоит упомянуть при объявлении класса.
 */
//Вот есть у нас трейт
trait Logger{
  def log(msg:String)
}
//Есть несколько наследующих его трейтов
trait ConsoleLogger extends Logger {
  def log(msg:String) = println(msg)
}
trait FileLogger extends Logger {
  def setFile(filePath:String): Unit ={
    out = new PrintWriter(filePath)
  }
  var out = new PrintWriter("output.txt")
  def log(msg:String) = out.println(msg)
}
//А вот какой-то абстрактный класс
abstract class Text extends Logger {

}
//А вот создаваемые объекты исполняют разные трейты
val o1 = new Text with ConsoleLogger
//val o2 = new Text with FileLogger у меня нет такого файла, так что кидает ошибку.
/**
 * Таким образом мы подмешиваем ту функциональность, которую хотим подмешать и тогда, когда хотим её подмешать.
 * Здесь нужно упомянуть, что сам пример с логгерами - на мой взгляд не столь удачен. В идеале основная логика про
 * логгер знать не должна. Максимум может присутствовать нотация типа @Loggable или что-то другое, указывающее на то,
 * что наш, например, класс будет логгирован.
*/
//--------------------------------------------------Многоуровневые трейты-----------------------------------------------
/**
 * Немного стрёмная шутка. Нет, серьёзно.
 */
//Вот есть у нас ограничитель длинны лога
trait ShortMsgLogger extends ConsoleLogger{
  /**
   * Вот тут важно, что super.log() - совсем не тоже самое, что это значило бы, будь ShortMsgLogger классом.
   * Будь он классом, таким образом мы бы просто обрезали сообщение и вызвали бы родительский метод.
   * НО в терминах трейтов эта шутка вызовет метод log следующего в иерархии трейта. Про иерархию - ниже.
   * @param msg
   */
  override def log(msg:String) = super.log(if(msg.length<=15) msg else s"${msg.substring(0,12)}...")
}
//Логгер выписывающий время, кстати, полезная штука.
trait CurrentTimeLogger extends ConsoleLogger{
  override def log(msg:String) = super.log(s"[${java.time.Instant.now}] $msg")
}
//Итак, иерархия: трейты исполняются справа налево.
val o3 = new Text with ShortMsgLogger with CurrentTimeLogger
val o4 = new Text with CurrentTimeLogger with ShortMsgLogger
//Вот тут очень хорошо видно.
o3.log("I need to log this long sentence")
o4.log("I need to log this long sentence")

/**
 * Если (вдруг) нужно использовать super.MethodName(...) как в классах, то можно сделать вот так:
 * super[ConsoleLogger].MethodName(...) но ConsoleLogger должен быть унаследован непосредственно.
 */
//-----------------------------------------------Поля в трейтах---------------------------------------------------------
//конкретные поля
trait maxLength{
  val maxLength = 10
}

/**
 * класс F получит поле maxLength как в трейте и с тем значением, которое указано в трейте.
 * НО, это поле не наследутеся, а добавляется в подкласс. То есть, для корректной работы после изменения трейта нужно
 * перекомпилировать все классы, где он подмешивается. Когда мы изменяем родительский класс, перекомпилировать его
 * подклассы не надо, так как JVM знает как работать с наследниками в этом случае.
 * А вот с трейтами так не получается, так как на самом деле они не наследуются в полном смысле слова.
 */
class F extends maxLength
(new F).maxLength
//абстрактные поля
trait ShortMessageLogger extends ConsoleLogger{
  val maxLength:Int //Вот оно, абстрактное поле. Теперь трейт нельзя подмешать не определив его.
  override def log(msg:String) = super.log(if(msg.length<=15) msg else s"${msg.substring(0,maxLength)}...")
}
//Подмешивание трейта вместе с определением
val o5 = new Text with ShortMessageLogger{
  val maxLength = 23
}

/**
 * В книге на этом месте описываются тонкости конструирования классов и трейтов в сложных случиях. Я просто перепишу.
 * Порядок конструирования:
 * 1. Суперкласс
 * 2. Конструкторы трейтов слева направо.
 * 3. Внутри каждого трейта первым делом выполняются конструкторы родительских трейтов
 * 4. Последним вызывается конструктор класса
 * Если несколько трейтов наследуют от одного родителя, то его конструктор выполняется только при первом вызове
 * (из самого левого наследника в определении объекта(класса))
 */

/**
 * Иногда хочется написать что-то типа
 *
 * val text = new Text with ShortMessageLogger(20), имея в виду, что maxLength = 20 в ShortMessageLogger
 * Но увы, не выйдет. Так как трейт может иметь единственный конструктор без параметров и не может иметь других.
 * Казалось бы, ерунда.
 *
 * val text = new Text with ShortMessageLogger{ val maxLength = 20}
 *
 * Но нет, это тоже выкинет ошибку. Ошибка связана с порядком конструирования. Мы создаём наследуем от класса Text и
 * создаём новый подкласс, наследующий трейт ShortMessageLogger, однако конструктор подкласса будет выполнен
 * в последнюю очередь, а значит конструктор ShortMessageLogger, вызванный раньше воткнётся в неинициализированное поле
 * и выкинет ошибку. Решение - опережающее наследование. Штука некрасивая, на мой вкус стрёмная, но решение есть решение
 * .
 */
val text = new {
  val maxLength = 20
} with Text with ShortMessageLogger
//Другой способ добиться того-же: сделать maxLength - lazy val, тогда всё будет ок.
//-------------------------------------------------Некоторая специфика--------------------------------------------------
/**
 * Трейты могут наследовать классы, однако в таком случае, любой класс, куда подмешивается такой трейт автоматически
 * наследуется от класса, от которого наследует трейт
 */
trait loggedException extends Exception with ConsoleLogger {
  def log() {log(getMessage)}
}
trait someException extends loggedException{
  override def getMessage() = "ah!..."
}
//При этом, всё ок, если суперкласс уже косвенно унаследован:
class otherException extends IOException with loggedException //всё ок
//и ошибка множественного наследования, если мы пытаемся подмешать трейт в посторонний класс.
class someClass
//class smthg extends someClass with someException            //кинет ошибку
/**
 * Вообще гарантия того, что наш трейт не будет подмешан непонятно-куда - это хорошо, так что
 * Есть механизм специализированный для таких вещей. Выглядит это так:
 */
trait LogEx extends ConsoleLogger {
  this: Exception=>
    def log(){log(getMessage())}
}
//теперь, если попытаться подмешать трейт куда-то кроме Exception - возникнет ошибка.
/**
 * Есть вот такая вот занятная конструкция:
 */
trait loggedEx extends ConsoleLogger {
  this:{ def getMessage():String }=>
  def log():Unit = log(getMessage())
}
/**
 * Такой трейт можно подмешать к любому классу, у которого есть метод getMessage():String
 */